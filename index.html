<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>chat</title>
	<style>
		@font-face {
			font-family: 'PerfectDOS';
			src: url('./PerfectDosVga.ttf') format('truetype');
		}
		* { font-family: 'PerfectDOS', monospace; margin: 0; padding: 0; box-sizing: border-box; }
		html, body { height: 100%; overflow: hidden; background: #0b0b0d; color: white; }
		
		body {
			border: 1px solid hsl(180,100%,50%);
			box-sizing: border-box;
		}
		
		.login-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(11,11,13,0.95);
			backdrop-filter: blur(8px);
			display: flex;
			align-items: center;
			justify-content: center;
			flex-direction: column;
			gap: 20px;
			z-index: 100;
		}
		.login-overlay h1 { 
			color: hsl(180,100%,50%); 
			font-size: 3rem; 
			margin-bottom: 1rem;
			animation: pulse 2s ease-in-out infinite;
		}
		@keyframes pulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.7; }
		}
		.enter-btn {
			background: hsl(180,100%,50%);
			color: #0b0b0d;
			padding: 16px 48px;
			border: none;
			font-size: 1.5rem;
			cursor: pointer;
			transition: all 0.3s;
		}
		.enter-btn:hover {
			transform: scale(1.05);
			box-shadow: 0 0 20px hsla(180,100%,50%,0.5);
		}
		
		.chat-app { 
			display: flex; 
			flex-direction: column; 
			height: 100dvh;
			overflow: hidden;
		}
		.floating-controls {
			position: fixed;
			top: 1rem;
			left: 1rem;
			display: flex;
			gap: 10px;
			z-index: 1000;
		}
		.username, .logout-btn { 
			padding: 8px 16px;
			background: rgba(11,11,13,0.9);
			border: 2px solid;
			backdrop-filter: blur(10px);
			cursor: pointer;
		}
		.username { color: hsl(180,100%,50%); border-color: hsl(180,100%,50%); }
		.logout-btn { color: hsl(0,100%,50%); border-color: hsl(0,100%,50%); }
		
		.messages {
			flex: 1;
			padding: 1rem;
			padding-top: 4rem;
			overflow-y: scroll;
			overflow-x: hidden;
			min-height: 0;
			-webkit-overflow-scrolling: touch;
		}
		.messages::-webkit-scrollbar {
			width: 1ch;
		}
		.messages::-webkit-scrollbar-track {
			background: #0b0b0d;
		}
		.messages::-webkit-scrollbar-thumb {
			background: hsl(180,100%,50%);
		}
		.messages-wrapper {
			display: flex;
			flex-direction: column;
			min-height: min-content;
		}
		.message {
			position: relative;
			font-size: 1.5rem;
			padding: 0.5rem 1rem;
			margin: 0.6rem 0;
			max-width: 60%;
			align-self: flex-end;
			background: #0b0b0d;
			border: 2px solid;
			cursor: pointer;
			transition: transform 0.1s;
		}
		.message:hover { transform: translateX(-2px); }
		.message .name, .message .time { position: absolute; background: #0b0b0d; }
		.message .name { top: -0.6em; left: .6em; font-size: 1.5rem; }
		.message .time { bottom: -0.6em; right: .6em; font-size: 1rem; }
		
		.system-message {
			align-self: flex-start;
			font-size: 1.2rem;
			color: white;
			background: transparent;
			border: 1px dashed #666;
			padding: 0.3rem 0.8rem;
			margin: 0.4rem 0;
			max-width: 50%;
			cursor: default;
		}
		.system-message:hover { transform: none; }
		.system-message .highlight {
			font-weight: bold;
		}
		
		.input-area { border-top: 2px solid #333; display: flex; }
		.input-area input {
			flex: 1;
			padding: 1rem;
			font-size: 1.5rem;
			background: #0b0b0d;
			color: hsl(var(--user-color, 180),100%,50%);
			border: none;
			outline: none;
		}
		.send-btn {
			padding: 1rem 1.5rem;
			font-size: 1.5rem;
			background: #0b0b0d;
			color: white;
			border: none;
			border-left: 2px solid #333;
			cursor: pointer;
		}
		
		.modal {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(11,11,13,0.5);
			backdrop-filter: blur(8px);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: 2000;
		}
		.modal-content {
			background: #0b0b0d;
			border: 2px solid white;
			padding: 2rem;
			min-width: 300px;
			max-width: 500px;
			width: 90%;
			max-height: 80vh;
			overflow-y: auto;
		}
		.modal-header {
			color: white;
			font-size: 1.5rem;
			margin-bottom: 1rem;
			display: flex;
			justify-content: space-between;
		}
		.modal input, .modal textarea {
			width: 100%;
			background: #0b0b0d;
			color: white;
			border: 2px solid #666;
			padding: 12px;
			font-size: 16px;
			outline: none;
			margin: 10px 0;
		}
		.modal textarea { color: white; min-height: 60px; resize: vertical; }
		.modal textarea:read-only { 
			opacity: 0.7;
			cursor: not-allowed;
		}
		.modal button {
			background: white;
			color: #0b0b0d;
			padding: 12px;
			border: none;
			cursor: pointer;
			width: 100%;
			font-size: 16px;
			margin-top: 10px;
		}
		.close-btn {
			background: transparent !important;
			color: hsl(0,100%,50%) !important;
			border: 2px solid hsl(0,100%,50%) !important;
			padding: 4px 12px !important;
			width: auto !important;
			margin: 0 !important;
		}
		.error { color: hsl(0,100%,50%); font-size: 0.9rem; margin-bottom: 10px; }
		
		.style-section { margin-top: 1.5rem; }
		.style-label {
			color: white;
			font-size: 1rem;
			margin-bottom: 0.8rem;
			display: block;
		}
		.color-grid {
			display: grid;
			grid-template-columns: repeat(12, 1fr);
			gap: 6px;
			margin-bottom: 1rem;
		}
		.color-option {
			aspect-ratio: 1;
			border: 2px solid transparent;
			cursor: pointer;
			transition: all 0.2s;
			width: 100%;
			height: 100%;
		}
		.color-option.selected {
			border-color: white;
			box-shadow: 0 0 8px rgba(255,255,255,0.5);
		}
		.border-options { display: flex; gap: 8px; }
		.border-option {
			flex: 1;
			padding: 8px;
			background: #0b0b0d;
			cursor: pointer;
			text-align: center;
			transition: all 0.2s;
			font-size: 0.85rem;
		}
		.border-option.selected {
			border-color: white;
			box-shadow: 0 0 8px rgba(255,255,255,0.5);
		}
		.loading {
			display: inline-block;
			width: 20px;
			height: 20px;
			border: 3px solid rgba(255,255,255,0.3);
			border-top-color: hsl(180,100%,50%);
			border-radius: 50%;
			animation: spin 1s linear infinite;
			margin-left: 10px;
		}
		@keyframes spin {
			to { transform: rotate(360deg); }
		}
	</style>
</head>
<body>
	<div id="app">
		<div class="chat-app">
			<div class="messages" id="messages">
				<div class="messages-wrapper" id="messagesWrapper"></div>
			</div>
			<div class="input-area">
				<input type="text" id="messageInput" placeholder="Type...">
				<button class="send-btn" id="sendBtn">SEND</button>
			</div>
		</div>
	</div>

	<script type="module">
		import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js';
		import { getAuth, signInAnonymously, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js';
		import { getDatabase, ref, push, onChildAdded, set, get, onDisconnect, onValue } from 'https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js';

		const app = initializeApp({
			apiKey: "AIzaSyB-UPrXMblPcO1gcdD0GuEhBA8JGMpbGs4",
			authDomain: "social-e02b4.firebaseapp.com",
			databaseURL: "https://social-e02b4-default-rtdb.firebaseio.com",
			projectId: "social-e02b4",
			storageBucket: "social-e02b4.firebasestorage.app",
			messagingSenderId: "64302705629",
			appId: "1:64302705629:web:9090276dba0418cee6e434"
		});

		const auth = getAuth(app);
		const db = getDatabase(app);
		const COLORS = [180, 210, 240, 270, 300, 330, 0, 30, 60, 90, 120, 150];

		let state = {
			user: null,
			username: '',
			color: '180',
			borderStyle: 'solid',
			about: '',
			input: '',
			showProfile: false,
			profileUid: null,
			profileData: null,
			showUsernamePrompt: false,
			usernameInput: '',
			error: '',
			isLoading: false,
			lastAnimatedId: null,
			hasJoinedChat: false,
			timeoutMsgRef: null
		};

		const messages = [];
		const loadedIds = new Set();
		const typingSound = new Audio('./sounds/terminal_cursor.wav');
		const finishSound = new Audio('./sounds/R_Terminal_ping.wav');

		// Cookie functions
		function setCookie(name, value, days = 365) {
			const expires = new Date();
			expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
			document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
		}

		function getCookie(name) {
			const nameEQ = name + "=";
			const ca = document.cookie.split(';');
			for (let c of ca) {
				c = c.trim();
				if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length);
			}
			return null;
		}

		// Load saved preferences from cookies
		function loadPreferences() {
			const savedUsername = getCookie('username');
			const savedColor = getCookie('color');
			const savedBorder = getCookie('borderStyle');
			const savedAbout = getCookie('about');
			
			if (savedUsername) state.usernameInput = savedUsername;
			if (savedColor) state.color = savedColor;
			if (savedBorder) state.borderStyle = savedBorder;
			if (savedAbout) state.about = decodeURIComponent(savedAbout);
		}

		// Save preferences to cookies
		function savePreferences() {
			setCookie('username', state.username);
			setCookie('color', state.color);
			setCookie('borderStyle', state.borderStyle);
			setCookie('about', encodeURIComponent(state.about));
		}

		// Setup input handlers once
		document.getElementById('messageInput').oninput = e => state.input = e.target.value;
		document.getElementById('messageInput').onkeypress = e => {
			if (e.key === 'Enter' && !e.shiftKey) {
				e.preventDefault();
				sendMessage();
			}
		};
		document.getElementById('sendBtn').onclick = sendMessage;

		// Listen to messages
		onChildAdded(ref(db, 'messages'), snapshot => {
			const id = snapshot.key;
			if (loadedIds.has(id)) return;
			loadedIds.add(id);

			const msg = { id, ...snapshot.val() };
			messages.push(msg);
			if (messages.length > 30) messages.shift();

			addMessageToDOM(msg, true);
		});

		function addMessageToDOM(msg, animate) {
			const container = document.getElementById('messagesWrapper');
			if (!container) return;

			while (container.children.length >= 30) {
				container.removeChild(container.firstChild);
			}

			const el = document.createElement('div');
			
			// Check if it's a system message
			if (msg.type === 'system') {
				el.className = 'system-message';
				// Parse the message to highlight the username
				const parts = msg.text.split(' ');
				if (parts.length >= 2) {
					const username = parts[0];
					const action = parts.slice(1).join(' ');
					const userColor = msg.userColor ? `hsl(${msg.userColor},100%,50%)` : 'white';
					el.innerHTML = `<span class="highlight" style="color: ${userColor}">${username}</span> ${action}`;
				} else {
					el.textContent = msg.text;
				}
			} else {
				el.className = 'message';
				const light = `hsl(${msg.color},100%,50%)`;
				const dark = `hsl(${msg.color},100%,30%)`;
				el.style.color = light;
				el.style.borderColor = dark;
				el.style.borderStyle = msg.borderStyle;
				el.onclick = () => openProfile(msg.userId);
				el.innerHTML = `
					<span class="name" style="color:${dark}"></span>
					<span class="text"></span>
					<span class="time" style="color:${dark}">${formatTime(msg.timestamp)}</span>
				`;
				
				if (animate && state.user) {
					animateMessage(el, msg.userName, msg.text);
				} else {
					el.querySelector('.name').textContent = msg.userName;
					el.querySelector('.text').textContent = msg.text;
				}
			}
			
			container.appendChild(el);

			const messagesContainer = document.getElementById('messages');
			if (messagesContainer) {
				messagesContainer.scrollTop = messagesContainer.scrollHeight;
			}
		}

		function animateMessage(el, userName, text) {
			const nameEl = el.querySelector('.name');
			const textEl = el.querySelector('.text');
			if (!nameEl || !textEl) return; // System message
			
			let ni = 0, ti = 0;
			function type() {
				let typed = false;
				if (ni < userName.length) {
					nameEl.textContent += userName[ni++];
					typed = true;
				}
				if (ti < text.length) {
					textEl.textContent += text[ti++];
					typed = true;
				}
				
				if (typed) {
					typingSound.currentTime = 0;
					typingSound.play().catch(() => {});
				}
				
				document.getElementById('messages').scrollTop = 9999;
				
				if (ni < userName.length || ti < text.length) {
					setTimeout(type, 80);
				} else {
					finishSound.currentTime = 0;
					finishSound.play().catch(() => {});
				}
			}
			type();
		}

		function formatTime(ts) {
			const d = new Date(ts);
			return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
		}

		async function sendMessage() {
			if (!state.user || !state.input.trim()) return;
			const msgRef = await push(ref(db, 'messages'), {
				userId: state.user.uid,
				userName: state.username,
				text: state.input.trim(),
				timestamp: Date.now(),
				color: state.color,
				borderStyle: state.borderStyle,
				type: 'user'
			});
			state.lastAnimatedId = msgRef.key;
			state.input = '';
			document.getElementById('messageInput').value = '';
		}

		async function sendSystemMessage(text, userColor = null) {
			await push(ref(db, 'messages'), {
				text: text,
				timestamp: Date.now(),
				type: 'system',
				userColor: userColor
			});
		}

		async function openProfile(uid) {
			const userRef = ref(db, `users/${uid}`);
			const snap = await get(userRef);
			const data = snap.val() || { username: 'User', about: '', color: '0', borderStyle: 'solid' };
			state.profileUid = uid;
			state.profileData = { ...data }; // Create a copy to edit
			state.showProfile = true;
			renderOverlay();
		}

		async function enterChat() {
			state.isLoading = true;
			renderOverlay();
			try {
				await signInAnonymously(auth);
			} catch (err) {
				console.error('Auth error:', err);
				state.error = 'Failed to enter chat';
				state.isLoading = false;
				renderOverlay();
			}
		}

		async function confirmUsername() {
			const un = state.usernameInput.trim();
			if (!un) {
				state.error = 'Enter a username';
				renderOverlay();
				return;
			}
			
			if (un.length < 2 || un.length > 20) {
				state.error = 'Username must be 2-20 characters';
				renderOverlay();
				return;
			}
			
			// Save to Firebase
			await set(ref(db, `users/${state.user.uid}`), {
				username: un,
				about: state.about,
				color: state.color,
				borderStyle: state.borderStyle
			});
			
			state.username = un;
			state.showUsernamePrompt = false;
			state.error = '';
			
			// Save preferences to cookies
			savePreferences();
			
			// Send join message
			if (!state.hasJoinedChat) {
				await sendSystemMessage(`${un} joined`, state.color);
				state.hasJoinedChat = true;
				// Setup presence after setting username
				await setupPresence();
			}
			
			renderOverlay();
		}

		function renderOverlay() {
			const existing = document.getElementById('overlay');
			if (existing) existing.remove();

			// Show loading/enter screen for non-authenticated users
			if (!state.user) {
				const div = document.createElement('div');
				div.id = 'overlay';
				div.className = 'login-overlay';
				div.innerHTML = `
					<h1>CHAT</h1>
					${state.error ? `<div class="error">${state.error}</div>` : ''}
					${state.isLoading ? 
						'<div class="loading"></div>' : 
						'<button class="enter-btn" id="enterBtn">ENTER</button>'
					}
				`;
				document.body.appendChild(div);
				if (!state.isLoading) {
					document.getElementById('enterBtn').onclick = enterChat;
				}
				return;
			}

			// Username prompt for new users
			if (state.showUsernamePrompt) {
				const div = document.createElement('div');
				div.id = 'overlay';
				div.className = 'modal';
				div.innerHTML = `
					<div class="modal-content">
						<div class="modal-header">CHOOSE USERNAME</div>
						${state.error ? `<div class="error">${state.error}</div>` : ''}
						<input id="unInput" type="text" value="${state.usernameInput}" maxlength="20" placeholder="Username" autocomplete="off">
						<input id="aboutInput" type="text" maxlength="50" placeholder="Status (optional)" style="margin:0;color:white" value="${state.about}">
						<div class="style-section">
							<span class="style-label">COLOR</span>
							<div class="color-grid" id="colorGrid">
								${COLORS.map(h => `<div class="color-option ${state.color==h?'selected':''}" data-color="${h}" style="background:hsl(${h},100%,50%);border:2px solid ${state.color==h?'white':'hsl('+h+',100%,30%)'}"></div>`).join('')}
							</div>
							<span class="style-label">BORDER</span>
							<div class="border-options">
								${['solid','dashed','dotted'].map(s => `<div class="border-option ${state.borderStyle===s?'selected':''}" data-style="${s}" style="border:2px ${s} hsl(${state.color},100%,30%)">${s.toUpperCase()}</div>`).join('')}
							</div>
						</div>
						<button id="confirmBtn">START CHATTING</button>
					</div>
				`;
				document.body.appendChild(div);
				const input = document.getElementById('unInput');
				input.focus();
				input.oninput = e => state.usernameInput = e.target.value;
				input.onkeypress = e => {
					if (e.key === 'Enter') {
						e.preventDefault();
						confirmUsername();
					}
				};
				document.getElementById('aboutInput').oninput = e => state.about = e.target.value;
				document.querySelectorAll('.color-option').forEach(el => {
					el.onclick = () => {
						state.color = el.dataset.color;
						renderOverlay();
					};
				});
				document.querySelectorAll('.border-option').forEach(el => {
					el.onclick = () => {
						state.borderStyle = el.dataset.style;
						renderOverlay();
					};
				});
				document.getElementById('confirmBtn').onclick = confirmUsername;
				return;
			}

			// Profile modal
			if (state.showProfile) {
				const div = document.createElement('div');
				div.id = 'overlay';
				div.className = 'modal';
				const userColor = `hsl(${state.profileData?.color || '0'},100%,50%)`;
				const isOwnProfile = state.profileUid === state.user?.uid;
				div.innerHTML = `
					<div class="modal-content" style="border-color: ${userColor}">
						<div class="modal-header" style="color: ${userColor}">
							<span>${state.profileData?.username || 'User'}</span>
							<button class="close-btn" id="closeBtn">CLOSE</button>
						</div>
						${isOwnProfile ? `
							<div style="color:${userColor};margin-bottom:0.5rem">CHANGE USERNAME</div>
							<input id="newUsernameInput" type="text" maxlength="20" placeholder="New username (leave empty to keep)" style="border-color: ${userColor}">
						` : ''}
						<div style="color:${userColor};margin-bottom:0.5rem">STATUS</div>
						<textarea id="aboutInput" maxlength="200" style="border-color: ${userColor}; min-height: 60px" ${!isOwnProfile ? 'readonly' : ''}>${state.profileData?.about || ''}</textarea>
						${isOwnProfile ? `
							<div class="style-section">
								<span class="style-label">COLOR</span>
								<div class="color-grid" id="colorGrid">
									${COLORS.map(h => `<div class="color-option ${state.profileData.color==h?'selected':''}" data-color="${h}" style="background:hsl(${h},100%,50%);border:2px solid ${state.profileData.color==h?'white':'hsl('+h+',100%,30%)'}"></div>`).join('')}
								</div>
								<span class="style-label">BORDER</span>
								<div class="border-options">
									${['solid','dashed','dotted'].map(s => `<div class="border-option ${state.profileData.borderStyle===s?'selected':''}" data-style="${s}" style="border:2px ${s} hsl(${state.profileData.color},100%,30%)">${s.toUpperCase()}</div>`).join('')}
								</div>
							</div>
							<button id="saveBtn" style="background: ${userColor}; color: #0b0b0d">SAVE CHANGES</button>
						` : ''}
					</div>
				`;
				document.body.appendChild(div);
				div.onclick = e => e.target.id === 'overlay' && (state.showProfile = false, renderOverlay());
				document.getElementById('closeBtn').onclick = () => { state.showProfile = false; renderOverlay(); };
				
				if (isOwnProfile) {
					document.getElementById('aboutInput').oninput = e => state.profileData.about = e.target.value;
					
					// Add color and border style handlers
					document.querySelectorAll('.color-option').forEach(el => {
						el.onclick = () => {
							state.profileData.color = el.dataset.color;
							renderOverlay();
						};
					});
					document.querySelectorAll('.border-option').forEach(el => {
						el.onclick = () => {
							state.profileData.borderStyle = el.dataset.style;
							renderOverlay();
						};
					});
					
					document.getElementById('saveBtn').onclick = async () => {
						if (!state.user) return;
						const newUsername = document.getElementById('newUsernameInput').value.trim();
						const oldUsername = state.username;
						
						// Check if username is changing
						if (newUsername && newUsername !== oldUsername) {
							if (newUsername.length < 2 || newUsername.length > 20) {
								alert('Username must be 2-20 characters');
								return;
							}
							
							// Send username change message
							await sendSystemMessage(`${oldUsername} is now ${newUsername}`, state.profileData.color);
							state.username = newUsername;
						}
						
						// Update all user data
						const userRef = ref(db, `users/${state.user.uid}`);
						await set(userRef, {
							username: state.username,
							about: state.profileData.about,
							color: state.profileData.color,
							borderStyle: state.profileData.borderStyle
						});
						
						// Update local state
						state.about = state.profileData.about;
						state.color = state.profileData.color;
						state.borderStyle = state.profileData.borderStyle;
						
						// Save to cookies
						savePreferences();
						
						// Update presence with new info
						if (newUsername) {
							await setupPresence();
						}
						
						state.showProfile = false;
						renderOverlay();
					};
				}
				return;
			}

			// Logged in - show controls
			const existing2 = document.getElementById('controls');
			if (existing2) existing2.remove();
			const div = document.createElement('div');
			div.id = 'controls';
			div.className = 'floating-controls';
			const userColor = `hsl(${state.color},100%,50%)`;
			div.innerHTML = `
				<span class="username" id="usernameBtn" style="color: ${userColor}; border-color: ${userColor}">${state.username}</span>
				<button class="logout-btn" id="logoutBtn">LEAVE</button>
			`;
			document.body.appendChild(div);
			document.getElementById('usernameBtn').onclick = () => openProfile(state.user.uid);
			document.getElementById('logoutBtn').onclick = async () => {
				try {
					// Cancel the timeout message since this is a clean logout
					if (state.timeoutMsgRef) {
						await onDisconnect(state.timeoutMsgRef).cancel();
					}
					
					// Send leave message before signing out
					if (state.username) {
						await sendSystemMessage(`${state.username} left`, state.color);
					}
					
					// Remove presence
					if (state.user) {
						const presenceRef = ref(db, `presence/${state.user.uid}`);
						await onDisconnect(presenceRef).cancel();
						await set(presenceRef, null);
					}
					
					// Clear user data and sign out
					state.user = null;
					state.username = '';
					state.hasJoinedChat = false;
					state.timeoutMsgRef = null;
					
					await signOut(auth);
					// Immediately update UI after signing out
					renderOverlay();
				} catch (err) {
					console.error('Logout error:', err);
					// Force logout even if there's an error
					state.user = null;
					state.username = '';
					state.hasJoinedChat = false;
					await signOut(auth);
					renderOverlay();
				}
			};
			
			// Update input color
			const messageInput = document.getElementById('messageInput');
			if (messageInput) {
				messageInput.style.color = userColor;
			}
			
			// Update scrollbar and border color
			document.body.style.borderColor = userColor;
			const style = document.createElement('style');
			style.id = 'dynamic-scrollbar';
			const existingStyle = document.getElementById('dynamic-scrollbar');
			if (existingStyle) existingStyle.remove();
			style.textContent = `.messages::-webkit-scrollbar-thumb { background: ${userColor}; }`;
			document.head.appendChild(style);
		}

		// Setup presence system for timeout detection
		async function setupPresence() {
			if (!state.user || !state.username) return;
			
			const presenceRef = ref(db, `presence/${state.user.uid}`);
			const connectedRef = ref(db, '.info/connected');
			
			// Listen to connection state
			onValue(connectedRef, async (snapshot) => {
				if (snapshot.val() === true && state.user && state.username) {
					// User is online
					await set(presenceRef, {
						username: state.username,
						color: state.color,
						online: true,
						timestamp: Date.now()
					});
					
					// Setup disconnect hook - this runs on the server when connection is lost
					await onDisconnect(presenceRef).remove();
					
					// Also queue a timeout message to be sent on disconnect
					// Create a unique key for the timeout message
					const timeoutMsgKey = `timeout_${state.user.uid}_${Date.now()}`;
					const timeoutMsgRef = ref(db, `messages/${timeoutMsgKey}`);
					
					await onDisconnect(timeoutMsgRef).set({
						text: `${state.username} timed out`,
						timestamp: Date.now(),
						type: 'system',
						userColor: state.color
					});
					
					// Store the timeout message reference so we can cancel it on clean logout
					state.timeoutMsgRef = timeoutMsgRef;
				}
			});
		}

		onAuthStateChanged(auth, async user => {
			if (user) {
				// Load preferences from cookies first
				loadPreferences();
				
				const snap = await get(ref(db, `users/${user.uid}`));
				if (!snap.exists() || !snap.val()?.username) {
					// New user - show username prompt with cookie values pre-filled
					state.user = user;
					state.showUsernamePrompt = true;
				} else {
					// Returning user (same session)
					state.user = user;
					const data = snap.val();
					state.username = data.username;
					state.color = data.color || '180';
					state.borderStyle = data.borderStyle || 'solid';
					state.about = data.about || '';
					state.showUsernamePrompt = false;
					
					// Send join message if not already sent
					if (!state.hasJoinedChat) {
						await sendSystemMessage(`${state.username} joined`, state.color);
						state.hasJoinedChat = true;
						// Setup presence after joining
						await setupPresence();
					}
				}
			} else {
				state.user = null;
				state.username = '';
				state.showUsernamePrompt = false;
				state.hasJoinedChat = false;
			}
			state.isLoading = false;
			renderOverlay();
		});

		// Load preferences on startup
		loadPreferences();
		renderOverlay();
	</script>
</body>
</html>